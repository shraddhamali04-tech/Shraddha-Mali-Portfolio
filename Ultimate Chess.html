<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Chess</title>
    <!-- Chess.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        /* --- Global Styles --- */
        :root {
            --bg-color: #0f172a;
            --text-color: #f8fafc;
            --accent-color: #06b6d4;
            --accent-glow: rgba(6, 182, 212, 0.5);
            --secondary-color: #1e293b;
            --highlight-color: #facc15;
           
            --sq-light: #e2e8f0;
            --sq-dark: #475569;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #1e293b 0%, #0f172a 100%);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        /* --- Sound Toggle --- */
        #sound-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        #sound-toggle:hover { background: var(--accent-color); color: #0f172a; box-shadow: 0 0 15px var(--accent-glow); }

        /* --- Page System --- */
        .page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: transparent;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        .hidden { display: none !important; }

        /* --- Start Page --- */
        h1 {
            font-size: 64px; 
            margin-bottom: 0; 
            color: white; 
            text-transform: uppercase; 
            letter-spacing: 5px; 
            text-shadow: 0 0 20px var(--accent-glow);
            white-space: nowrap; /* Forces one line */
            text-align: center;
        }
        .subtitle { font-size: 16px; color: #94a3b8; letter-spacing: 4px; margin-bottom: 60px; text-transform: uppercase; }
       
        .btn-main {
            padding: 20px 70px;
            font-size: 28px;
            background: linear-gradient(135deg, var(--accent-color), #3b82f6);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px var(--accent-glow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .btn-main:hover { transform: translateY(-5px); box-shadow: 0 15px 40px var(--accent-glow); }
        .btn-main:active { transform: scale(0.95); }

        /* --- Loading Page --- */
        .loader {
            width: 70px; height: 70px;
            border: 5px solid rgba(255,255,255,0.1);
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
            box-shadow: 0 0 20px var(--accent-glow);
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* --- Selection Page (Holographic Cards) --- */
        .selection-container {
            width: 90%;
            max-width: 900px;
            padding: 50px;
            background: rgba(30, 41, 59, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            perspective: 1000px;
        }

        .mode-grid {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin: 40px 0;
            width: 100%;
        }

        .mode-card {
            width: 280px;
            height: 320px;
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            transform-style: preserve-3d;
        }

        .card-content {
            transform: translateZ(40px);
            text-align: center;
            pointer-events: none;
        }

        .mode-card i { font-size: 60px; color: var(--accent-color); display: block; margin-bottom: 20px; filter: drop-shadow(0 0 10px var(--accent-glow)); font-style: normal; }
        .mode-card h3 { font-size: 24px; margin: 0; color: white; }
        .mode-card p { font-size: 14px; color: #94a3b8; margin-top: 10px; }

        .mode-card:hover {
            box-shadow: 0 20px 40px rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.4);
        }

        .mode-card.active {
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 30px var(--accent-glow);
            transform: scale(1.05) translateZ(20px) !important;
        }
        .mode-card.dimmed {
            opacity: 0.3;
            filter: grayscale(100%);
            transform: scale(0.9) !important;
            pointer-events: none;
        }

        #difficulty-section {
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .diff-grid { display: flex; gap: 20px; margin-top: 20px; }

        .btn-diff {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: #1e293b;
            color: white;
            border: 2px solid #334155;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
       
        .btn-diff:hover {
            background: #334155;
            border-color: var(--accent-color);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .btn-diff:active { transform: translateY(1px); box-shadow: inset 0 2px 4px rgba(0,0,0,0.4); }

        .back-link {
            margin-top: 30px;
            color: #94a3b8;
            cursor: pointer;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: color 0.3s;
        }
        .back-link:hover { color: white; }

        /* --- Game Page --- */
        #game-container { display: flex; gap: 30px; align-items: flex-start; z-index: 5; }
        .sidebar { display: flex; flex-direction: column; gap: 20px; min-width: 200px; }
        .stat-box { background: var(--secondary-color); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid #334155; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        #timer { font-size: 36px; font-family: monospace; color: var(--accent-color); text-shadow: 0 0 10px var(--accent-glow); }
        #status-text { font-size: 18px; font-weight: bold; min-height: 27px;}
        #mode-display { font-size: 12px; color: #94a3b8; text-transform: uppercase; }
        .btn-small { padding: 12px; background: #ef4444; border: none; color: white; border-radius: 8px; cursor: pointer; width: 100%; transition: 0.2s; font-weight: bold;}
        .btn-small:hover { background: #dc2626; }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 5px solid var(--secondary-color);
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            background: #0f172a;
        }
        .square { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 40px; cursor: pointer; position: relative; user-select: none; }
        .white { background-color: var(--sq-light); color: black; }
        .black { background-color: var(--sq-dark); color: black; }
        .selected { background-color: var(--accent-color) !important; box-shadow: inset 0 0 20px rgba(0,0,0,0.2); }
        .last-move { background-color: rgba(250, 204, 21, 0.4) !important; }
        .possible-move::after { content: ''; width: 15px; height: 15px; background: rgba(0,0,0,0.3); border-radius: 50%; position: absolute; }
        .check-danger { background-color: #ef4444 !important; animation: pulseRed 1s infinite; }
        @keyframes pulseRed { 0% { box-shadow: inset 0 0 0 red; } 50% { box-shadow: inset 0 0 20px red; } 100% { box-shadow: inset 0 0 0 red; } }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 40px; letter-spacing: 2px; } /* Adjusted for mobile */
            #game-container { flex-direction: column-reverse; align-items: center; gap: 10px; }
            #board { transform: scale(0.8); transform-origin: top center; margin-bottom: 20px; }
            .mode-grid { flex-direction: column; gap: 20px; }
            .sidebar { width: 100%; min-width: unset; flex-direction: row; justify-content: space-between; }
            .stat-box { flex: 1; padding: 10px; }
            #timer { font-size: 24px; }
        }
    </style>
</head>
<body>

    <!-- Sound Control -->
    <button id="sound-toggle" onclick="toggleSound()" title="Toggle Sound">üîä</button>

    <!-- 1. Start Page -->
    <div id="page-start" class="page">
        <!-- Removed <br>, forced one line via CSS -->
        <h1>Grandmaster Chess</h1>
        <p class="subtitle">Next Gen Edition</p>
        <button class="btn-main" onclick="startFlow()">INITIALIZE</button>
    </div>

    <!-- 2. Loading Page -->
    <div id="page-loading" class="page hidden">
        <div class="loader"></div>
        <h2 style="color: #94a3b8; letter-spacing: 2px;">GENERATING BOARD...</h2>
    </div>

    <!-- 3. Selection Page -->
    <div id="page-level" class="page hidden">
        <div class="selection-container">
            <h2 style="margin-top:0; color:white;">SELECT GAME MODE</h2>
           
            <div class="mode-grid">
                <!-- AI Card -->
                <div class="mode-card" id="card-ai" onclick="selectMode('ai')">
                    <div class="card-content">
                        <i>ü§ñ</i>
                        <h3>VS COMPUTER</h3>
                        <p>Artificial Intelligence</p>
                    </div>
                </div>
               
                <!-- Player Card -->
                <div class="mode-card" id="card-pvp" onclick="selectMode('pvp')">
                    <div class="card-content">
                        <i>üë•</i>
                        <h3>VS PLAYER</h3>
                        <p>Local Multiplayer</p>
                    </div>
                </div>
            </div>

            <div id="difficulty-section">
                <h3 style="color: var(--accent-color); margin-bottom: 10px;">AI DIFFICULTY</h3>
                <div class="diff-grid">
                    <button class="btn-diff" onclick="launchGame(1)">EASY</button>
                    <button class="btn-diff" onclick="launchGame(2)">MEDIUM</button>
                    <button class="btn-diff" onclick="launchGame(3)">HARD</button>
                </div>
                <div class="back-link" onclick="resetSelection()">‚Üê Back</div>
            </div>
        </div>
    </div>

    <!-- 4. Game Page -->
    <div id="page-game" class="hidden">
        <div id="game-container">
            <div class="sidebar">
                <div class="stat-box">
                    <div id="mode-display">Mode</div>
                    <div style="font-size:12px; opacity:0.6; margin-top:5px;">TIMER</div>
                    <div id="timer">00:00</div>
                </div>
                <div class="stat-box">
                    <div id="status-text">Ready</div>
                </div>
                <button class="btn-small" onclick="location.reload()">EXIT GAME</button>
            </div>
            <div id="board"></div>
        </div>
    </div>

    <script>
        // --- Sound System (Web Audio API) ---
        let audioCtx;
        let isSoundEnabled = true;

        // Initialize Audio Context on first user interaction to comply with browser policies
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!isSoundEnabled || !audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'click') {
                // UI Click: Short, high tick
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } 
            else if (type === 'select') {
                // Piece Select: Ping sound
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } 
            else if (type === 'move') {
                // Move: Soft wood-like tick
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } 
            else if (type === 'capture') {
                // Capture: Heavier, crunch sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
            else if (type === 'check') {
                // Check: Alarm
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            }
            else if (type === 'win') {
                // Win: Chord
                playNote(523.25, now, 0.5); // C5
                playNote(659.25, now, 0.5); // E5
                playNote(783.99, now, 0.5); // G5
            }
        }

        function playNote(freq, now, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            osc.start(now);
            osc.stop(now + duration);
        }

        function toggleSound() {
            isSoundEnabled = !isSoundEnabled;
            document.getElementById('sound-toggle').textContent = isSoundEnabled ? 'üîä' : 'üîá';
        }

        // --- Core Game Variables ---
        let game = new Chess();
        let boardEl = document.getElementById('board');
        let selectedSquare = null;
        let gameMode = '';
        let aiDepth = 2;
        let moveTimerInterval;
        let secondsElapsed = 0;
        const pieceValues = { p: 10, n: 30, b: 30, r: 50, q: 90, k: 900 };

        // --- Navigation ---

        function startFlow() {
            initAudio(); // Initialize audio on first click
            playSound('click');
            document.getElementById('page-start').classList.add('hidden');
            document.getElementById('page-loading').classList.remove('hidden');
            setTimeout(() => {
                document.getElementById('page-loading').classList.add('hidden');
                document.getElementById('page-level').classList.remove('hidden');
            }, 1500);
        }

        function selectMode(mode) {
            playSound('click');
            gameMode = mode;
            const diffSection = document.getElementById('difficulty-section');
            const cardAi = document.getElementById('card-ai');
            const cardPvp = document.getElementById('card-pvp');

            if (mode === 'pvp') {
                launchGame(null);
            } else {
                diffSection.style.display = 'flex';
                cardAi.classList.add('active');
                cardPvp.classList.add('dimmed');
            }
        }

        function resetSelection() {
            playSound('click');
            const diffSection = document.getElementById('difficulty-section');
            const cardAi = document.getElementById('card-ai');
            const cardPvp = document.getElementById('card-pvp');
           
            diffSection.style.display = 'none';
            cardAi.classList.remove('active');
            cardPvp.classList.remove('dimmed');
        }

        function launchGame(difficulty) {
            playSound('click');
            if (difficulty) aiDepth = difficulty;
           
            document.querySelectorAll('.page').forEach(p => p.classList.add('hidden'));
            document.getElementById('page-game').classList.remove('hidden');
           
            document.getElementById('mode-display').textContent = gameMode === 'ai' ? "VS COMPUTER" : "VS PLAYER";
            initGame();
        }

        // --- 3D Tilt Effect Logic ---
        const cards = document.querySelectorAll('.mode-card');
        cards.forEach(card => {
            card.addEventListener('mousemove', (e) => {
                if (card.classList.contains('dimmed') || document.getElementById('difficulty-section').style.display === 'flex') return;
               
                const rect = card.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
               
                const rotateX = ((y - centerY) / centerY) * -15;
                const rotateY = ((x - centerX) / centerX) * 15;
               
                card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.05)`;
            });
           
            card.addEventListener('mouseleave', () => {
                if (!card.classList.contains('active') && !card.classList.contains('dimmed')) {
                    card.style.transform = `perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1)`;
                }
            });
        });

        // --- Closing Alert ---
        window.addEventListener('beforeunload', function (e) {
            if (!document.getElementById('page-game').classList.contains('hidden')) {
                e.preventDefault(); e.returnValue = '';
            }
        });

        // --- Game Logic ---
        function initGame() {
            game.reset();
            selectedSquare = null;
            renderBoard();
            startTimer();
            updateStatus();
        }

        function startTimer() {
            clearInterval(moveTimerInterval);
            secondsElapsed = 0;
            document.getElementById('timer').innerText = "00:00";
            moveTimerInterval = setInterval(() => {
                secondsElapsed++;
                let mins = Math.floor(secondsElapsed / 60);
                let secs = secondsElapsed % 60;
                document.getElementById('timer').innerText =
                    (mins < 10 ? "0" : "") + mins + ":" + (secs < 10 ? "0" : "") + secs;
            }, 1000);
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const boardState = game.board();
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const squareDiv = document.createElement('div');
                    const isWhiteSquare = (r + c) % 2 === 0;
                    const squareName = String.fromCharCode(97 + c) + (8 - r);
                    squareDiv.className = `square ${isWhiteSquare ? 'white' : 'black'}`;
                    squareDiv.dataset.square = squareName;
                    squareDiv.onclick = () => onSquareClick(squareName);
                   
                    const history = game.history({ verbose: true });
                    if (history.length > 0) {
                        const lastMove = history[history.length - 1];
                        if (lastMove.from === squareName || lastMove.to === squareName) {
                            squareDiv.classList.add('last-move');
                        }
                    }
                    if (selectedSquare === squareName) squareDiv.classList.add('selected');
                   
                    const piece = boardState[r][c];
                    if (piece) {
                        const unicode = getUnicodePiece(piece);
                        squareDiv.textContent = unicode;
                        if (selectedSquare) {
                            const moves = game.moves({ square: selectedSquare, verbose: true });
                            const move = moves.find(m => m.to === squareName);
                            if (move) squareDiv.classList.add('possible-move');
                        }
                    }
                    if (game.in_check() && piece && piece.type === 'k' && piece.color === game.turn()) {
                        squareDiv.classList.add('check-danger');
                    }
                    boardEl.appendChild(squareDiv);
                }
            }
        }

        function getUnicodePiece(piece) {
            const symbols = { p: '‚ôü', n: '‚ôû', b: '‚ôù', r: '‚ôú', q: '‚ôõ', k: '‚ôö', P: '‚ôô', N: '‚ôò', B: '‚ôó', R: '‚ôñ', Q: '‚ôï', K: '‚ôî' };
            return symbols[piece.type] || '';
        }

        function updateStatus() {
            const statusEl = document.getElementById('status-text');
            if (game.in_checkmate()) { 
                statusEl.textContent = `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} Wins!`; 
                clearInterval(moveTimerInterval); 
                playSound('win');
            }
            else if (game.in_draw()) { statusEl.textContent = "Game Draw!"; clearInterval(moveTimerInterval); }
            else {
                if (game.in_check()) playSound('check'); // Play check sound

                if (gameMode === 'ai') statusEl.textContent = game.turn() === 'w' ? "Your Turn" : "AI Thinking...";
                else statusEl.textContent = game.turn() === 'w' ? "White's Turn" : "Black's Turn";
            }
        }

        function onSquareClick(square) {
            if (gameMode === 'ai' && game.turn() === 'b') return;
            if (game.game_over()) return;

            if (!selectedSquare) {
                const piece = game.get(square);
                if (piece && piece.color === game.turn()) { 
                    selectedSquare = square; 
                    playSound('select');
                    renderBoard(); 
                }
            } else {
                if (selectedSquare === square) { 
                    selectedSquare = null; 
                    renderBoard(); 
                }
                else {
                    const moves = game.moves({ square: selectedSquare, verbose: true });
                    const move = moves.find(m => m.to === square);
                    if (move) {
                        // Determine sound type
                        if(move.captured) playSound('capture');
                        else playSound('move');

                        game.move(move.san);
                        selectedSquare = null;
                        renderBoard();
                        startTimer();
                        if (!game.game_over() && gameMode === 'ai' && game.turn() === 'b') setTimeout(makeAIMove, 100);
                    } else {
                        const piece = game.get(square);
                        if (piece && piece.color === game.turn()) { 
                            selectedSquare = square; 
                            playSound('select');
                            renderBoard(); 
                        }
                        else { selectedSquare = null; renderBoard(); }
                    }
                }
            }
        }

        // --- AI Logic (Minimax) ---
        function evaluateBoard(board) {
            let totalEvaluation = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        const value = pieceValues[piece.type];
                        totalEvaluation += (piece.color === 'w' ? value : -value);
                    }
                }
            }
            return totalEvaluation;
        }

        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) return -evaluateBoard(game.board());
            const moves = game.moves();
            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (let i = 0; i < moves.length; i++) {
                    game.move(moves[i]);
                    const eval = minimax(depth - 1, alpha, beta, false);
                    game.undo();
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let i = 0; i < moves.length; i++) {
                    game.move(moves[i]);
                    const eval = minimax(depth - 1, alpha, beta, true);
                    game.undo();
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function makeAIMove() {
            const moves = game.moves();
            let bestMove = null;
            let bestValue = Infinity;
            let alpha = -Infinity;
            let beta = Infinity;
            moves.sort(() => Math.random() - 0.5);

            for (let i = 0; i < moves.length; i++) {
                game.move(moves[i]);
                const boardValue = minimax(aiDepth - 1, alpha, beta, true);
                game.undo();
                if (boardValue < bestValue) {
                    bestValue = boardValue;
                    bestMove = moves[i];
                }
                beta = Math.min(beta, bestValue);
                if (beta <= alpha) break;
            }
            game.move(bestMove);
            
            // AI Sound Effect
            const moveDetails = game.history({verbose: true}).pop();
            if (moveDetails.captured) playSound('capture');
            else playSound('move');

            renderBoard();
            startTimer();
        }
    </script>
</body>
</html>